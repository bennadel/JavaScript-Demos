{"version":3,"sources":["../src/utils/deep_copy.ts"],"names":["deepCopy","deepExtend","patchProperty","value","undefined","target","source","Object","constructor","Date","dateValue","getTime","Array","prop","hasOwnProperty","obj"],"mappings":";;;;;QAmBMA,Q,GAAAA,Q;QAgBAC,U,GAAAA,U;QAuCAC,a,GAAAA,a;AA1EN;;;;;;;;;;;;;;;AAgBA;;;AAGM,SAAAF,QAAA,CAAsBG,KAAtB,EAA8B;AAClC,WAAOF,WAAWG,SAAX,EAAsBD,KAAtB,CAAP;AACD;AAED;;;;;;;;;;;;AAYM,SAAAF,UAAA,CAAqBI,MAArB,EAAkCC,MAAlC,EAA6C;AACjD,QAAI,EAAEA,kBAAkBC,MAApB,CAAJ,EAAiC;AAC/B,eAAOD,MAAP;AACD;AAED,YAAQA,OAAOE,WAAf;AACE,aAAKC,IAAL;AACE;AACA;AACA,gBAAIC,YAAaJ,MAAjB;AACA,mBAAO,IAAIG,IAAJ,CAASC,UAAUC,OAAV,EAAT,CAAP;AAEF,aAAKJ,MAAL;AACE,gBAAIF,WAAWD,SAAf,EAA0B;AACxBC,yBAAS,EAAT;AACD;AACD;AAEF,aAAKO,KAAL;AACE;AACAP,qBAAS,EAAT;AACA;AAEF;AACE;AACA,mBAAOC,MAAP;AApBJ;AAuBA,SAAK,IAAIO,IAAT,IAAiBP,MAAjB,EAAyB;AACvB,YAAI,CAACA,OAAOQ,cAAP,CAAsBD,IAAtB,CAAL,EAAkC;AAChC;AACD;AACDR,eAAOQ,IAAP,IAAeZ,WAAWI,OAAOQ,IAAP,CAAX,EAAyBP,OAAOO,IAAP,CAAzB,CAAf;AACD;AAED,WAAOR,MAAP;AACD;AAED;AACM,SAAAH,aAAA,CAAwBa,GAAxB,EAAkCF,IAAlC,EAAgDV,KAAhD,EAA0D;AAC9DY,QAAIF,IAAJ,IAAYV,KAAZ;AACD","file":"deep_copy.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nexport function deepCopy<T>(value: T): T {\n  return deepExtend(undefined, value);\n}\n\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\nexport function deepExtend(target: any, source: any): any {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      let dateValue = (source as any) as Date;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n      break;\n\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (let prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\n// TODO: Really needed (for JSCompiler type checking)?\nexport function patchProperty(obj: any, prop: string, value: any) {\n  obj[prop] = value;\n}\n"]}