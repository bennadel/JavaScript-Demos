<!doctype html>
<html ng-app="Demo">
<head>
	<meta charset="utf-8" />

	<title>
		Refactoring bnRepeatSwitch To Use A Multi-Priority Directive In AngularJS
	</title>

	<style type="text/css">

		a[ ng-click ] {
			cursor: pointer ;
			text-decoration: underline ;
		}

		.invitation {
			color: #AAAAAA ;
			font-style: italic ;
		}

	</style>
</head>
<body ng-controller="AppController">

	<h1>
		Refactoring bnRepeatSwitch To Use A Multi-Priority Directive In AngularJS
	</h1>

	<h2>
		Your Team &mdash;
		{{ users.length }} users and 
		{{ invitations.length }} outstanding invitations.
	</h2>

	<ul>
		<!--
			For each item, we are "switching" the rendering template based on the 
			"isInvitation" flag that was injected into each item. Note, however, that we 
			are NOT using the core ngSwitch directive - we are replacing it with a custom
			directive that will pre-compile the "case" templates once and then simply 
			clone / link them during the ngRepeat rendering.
		-->
		<li 
			ng-repeat="person in people track by person.uid"
			bn-repeat-switch="person.isInvitation" 
			switch-once="true">

			<!-- BEGIN: Template for Invitation. -->
			<div bn-repeat-switch-when="true" class="invitation">

				{{ person.email }} 
				( <a ng-click>Resend</a> or <a ng-click>Cancel</a> invitation )

			</div>
			<!-- END: Template for Invitation. -->

			<!-- BEGIN: Template for User. -->
			<div bn-repeat-switch-when="false" class="user">

				{{ person.name }} &mdash; {{ person.email }}

			</div>	
			<!-- END: Template for User. -->

		</li>
	</ul>


	<!-- Load scripts. -->
	<script type="text/javascript" src="../../vendor/jquery/jquery-2.1.0.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs/angular-1.2.22.min.js"></script>
	<script type="text/javascript">

		// Create an application module for our demo.
		var app = angular.module( "Demo", [] );


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		// I control the root of the application.
		app.controller(
			"AppController",
			function( $scope ) {

				// Let's generate a large collection of invitations and users in such a
				// way that they mix together nicely (rather than one group after the 
				// other). We need to have a large group since we are looking at 
				// performance, which typically becomes more obvious at larger sizes.
				$scope.invitations = [];
				$scope.users = [];

				// Build each set programmatically.
				for ( var i = 1 ; i < 1000 ; i++ ) {

					$scope.invitations.push({
						id: i,
						email: ( "ben+" + i + "@bennadel.com" )
					});

					$scope.users.push({
						id: i,
						name: ( "ben+" + i ),
						email: ( "ben+" + i + "@bennadel.com" )
					});

				}

				// I hold the co-mingled collection of active users and pending 
				// invitations. Since this list is the aggregate of two different and
				// unique sets of data, this collection has its own unique identifier
				// - uid - injected into each item.
				$scope.people = buildPeople( $scope.invitations, $scope.users );


				// ---
				// PRIVATE METHODS.
				// ---	


				// I merge the given invitations and users collections into a single 
				// collection with unique ID (generated from the collection type and 
				// the ids of each item).
				function buildPeople( invitations, users ) {

					var people = sortPeople( invitations.concat( users ) );

					for ( var i = 0 ; i < people.length ; i++ ) {

						var person = people[ i ];

						// I determine if the given item is an invitation or a user.
						person.isInvitation = ! person.hasOwnProperty( "name" );

						// I build the unique ID for the item in the merged collection.
						person.uid = ( ( person.isInvitation ? "invitation-" : "user-" ) + person.id );

					}

					return( people );

				}
				

				// I sort the collection based on either name or email. Since I am 
				// sorting a mixed-collection, I am expecting not all elements to have 
				// a name; BUT, I am expecting all elements to have an email.
				function sortPeople( people ) {

					people.sort(
						function comparisonOperator( a, b ) {

							var nameA = ( a.name || a.email ).toLowerCase();
							var nameB = ( b.name || b.email ).toLowerCase();

							if ( nameA < nameB ) {

								return( -1 );

							} else if ( nameA > nameB ) {

								return( 1 );

							} else {

								return( 0 );

							}
							
						}
					);

					return( people );

				}

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		// I am a Switch/Case directive that is intended to work in conjunction with 
		// an ngRepat directive. I precompile the children tags with the attribute, 
		// "bn-repeat-switch-when (case/when) tags and then link them for each cloned
		// item in the ngRepeat rendering. Currently, this directive will clear out the
		// contents of the ngRepeat before rendering the appropriate "case" template.
		app.directive(
			"bnRepeatSwitch",
			function( $parse, $compile ) {

				// I provide a means to pass the switch expression, switch cases, and
				// other settings from this "priority" of the directive to the next 
				// priority of the same directive.
				function Controller() {

					// I hold the parsed expression that each ngRepeat clone will have 
					// to $watch() in order to figure out which template to render.
					this.expression = null;

					// I hold the linking functions for each "case" template.
					// --
					// NOTE: I am using .create(null) here in order to make sure that 
					// this object does NOT inherit keys from any other prototype. This 
					// allows us to check keys on this object without having to worry 
					// about inheritance (supported in IE9+).
					this.cases = Object.create( null );

					// I determine if the switch-expression should be allowed to change
					// once, or multiple times. If only once, the code is optimized to
					// stop caring.
					this.switchOnce = false;

				}


				// I compile the ngRepeat element (before ngRepeat executes) in order to
				// pre-compile the rendering templates and prepare the linking functions.
				function compile( tElement, tAttributes ) {

					// Parse the expression that we want to watch/switch-on in each of 
					// the individual ngRepeat elements. By parsing it here, during the 
					// compilation phase, we save the overhead of having to parse it 
					// every time the ngRepeat elements is cloned and linked.
					var switchExpression = $parse( tAttributes.bnRepeatSwitch );

					// Find all the children elements that make up the "case" statements,
					// strip them out, and compile them. This way, we can simply clone 
					// and link them later on.
					// --
					// NOTE: Since we are manually querying the DOM for these elements, 
					// we have to make assumptions about the format of the target 
					// attribute. We don't get to rely on the normalization AngularJS 
					// usually gives us (in the Attributes collection).
					var switchCases = {};

					// Check to see if the user only wants to check the switch expression
					// once; this will allow the watchers to unbind after the first digest
					// which should help with long-term performance of the page.
					var switchOnce = ( tAttributes.switchOnce === "true" );

					// Find, compile, and remove case-templates.
					tElement
						.children( "[ bn-repeat-switch-when ]" )
						.remove()
						.each(
							function iterateOverCaseTemplates() {

								var node = angular.element( this );
								var caseValue = node.attr( "bn-repeat-switch-when" );
								var caseLinkFunction = $compile( node.removeAttr( "bn-repeat-switch-when" ) );

								switchCases[ caseValue ] = caseLinkFunction;

							}
						)
					;

					// Clear out any remaining content - the current state of this 
					// directive is not designed to use positional DOM insertion (the way
					// that ngSwitchWhen does).
					tElement.empty();

					// Remove the switch-once attribute (if exists); we no longer need it
					// and it will only add weight to the DOM at this point.
					if ( "switchOnce" in tAttributes ) {

						tElement.removeAttr( tAttributes.$attr.switchOnce );
						
					}

					// Clean up references that we no longer need.
					tElement = null;
					tAttributes = null;

					// Return the linking function (which will run before the ngRepeat
					// linking phase).
					return( link );

					
					// The primary purpose of this linking phase, for this directive, 
					// is to copy the switch expression and the case-link-functions into
					// the current Controller so that they can be made available to the
					// lower-priority version of this directive (which will link every 
					// time the ngRepeat element is cloned and linked).
					function link( $scope, element, attributes, controller ) {

						// Store the switch configuration. 
						controller.expression = switchExpression;
						controller.cases = switchCases;
						controller.switchOnce = switchOnce;

						// Since our Controller is going to be passed-around, we should
						// probably tear it down in order to help prevent unexpected 
						// memory references from sticking around.
						$scope.$on(
							"$destroy",
							function handleDestroyEvent() {

								controller.expression = null;
								controller.cases = null;
								controller.switchOnce = null;
								controller = null;

								// NOTE: We cannot tear-down compiled elements as those
								// may be used in a subsequent linking phase.

							}
						);

					}

				}
				

				// Return the directive configuration. Note that this "version" of the 
				// bnRepeatSwitch directive has to execute with priority 1,001 so that 
				// it is compiled BEFORE the ngRepeat is compiled and linked (at 1,000).
				return({
					compile: compile,
					controller: Controller,
					priority: 1001,
					required: "bnRepeatSwitch",
					restrict: "A"
				});

			}
		);


		// The first version of the bnRepeatSwitch directive runs before the ngRepeat 
		// directive has had a chance to transclude (compile) the content; now, that 
		// the element has been compiled, this version of the bnRepeatSwitch directive 
		// will run at a lower priority and will link AFTER the ngRepeat directive has 
		// been linkd (once for each cloned element).
		app.directive(
			"bnRepeatSwitch",
			function() {

				// After each ngRepeat element is cloned and linked I set up the watcher
				// to render the appropriate template as the expression outcome changes.
				function link( scope, element, attributes, switchController ) {

					// Start watching the precompiled expression.
					var stopWatching = scope.$watch(
						switchController.expression,
						function handleSwitchExpressionChange( newValue, oldValue ) {

							// If the user does not expect the switch expression to ever
							// change, then we can unbind the watcher after the watcher 
							// is configured.
							if ( switchController.switchOnce ) {

								stopWatching();

							}

							var linkFunction = switchController.cases[ newValue ];

							// If there was no matching case statement template, just 
							// clear out the content.
							if ( ! linkFunction ) {

								return( element.empty() );

							}

							// If the expression outcome is changing, clear out the 
							// content before rendering the new template.
							if ( newValue !== oldValue ) {

								element.empty();	

							}

							// Clone the case template and inject it into the DOM.
							linkFunction(
								scope,
								function handleCaseTemplateCloneLinking( clone ) {

									element.append( clone );

								}
							);

						}
					);

				}


				// Return the directives configuration. Require the Controller from the 
				// higher-priority version of the bnRepeatSwitch directive so that we can
				// access the Expression and Case templates that were generated during 
				// the compile phase.
				// --
				// NOTE: This directive has to execute with the priority 999 so that it
				// is linked AFTER the ngRepeat directive is linked (at 1,000). 
				return({
					link: link,
					priority: 999,
					require: "bnRepeatSwitch",
					restrict: "A"
				});
			}
		);

	</script>

</body>
</html>
