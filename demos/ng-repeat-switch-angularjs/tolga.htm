<!doctype html>
<html ng-app="Demo">
<head>
	<meta charset="utf-8" />

	<title>
		Creating An Optimized Switch Directive For Use With ngRepeat In AngularJS
	</title>

	<style type="text/css">

		a[ ng-click ] {
			cursor: pointer ;
			text-decoration: underline ;
		}

		.invitation {
			color: #AAAAAA ;
			font-style: italic ;
		}

	</style>
</head>
<body ng-controller="AppController">

	<h1>
		Creating An Optimized Switch Directive For Use With ngRepeat In AngularJS
	</h1>

	<h2>
		Your Team &mdash;
		{{ users.length }} users and 
		{{ invitations.length }} outstanding invitations.
	</h2>

	<p>
		<a ng-click="toggleList()">Toggle list</a> <em>To explore memory leaks</em>.
	</p>

	<!-- UI-IF to explore memory deallocation. -->
	<ul ng-if="isShowingList">

		<!-- Nested NG-REPEAT to explore multiple linking phases. -->
		<li ng-repeat="people in collections">

			<ul>
				<li 
					ng-repeat="person in people track by person.uid"
					bn-repeat-switch="person.isInvitation">

					<!-- BEGIN: Template for Invitation. -->
					<div bn-repeat-switch-when="true" class="invitation">

						{{ person.email }} 
						( <a ng-click>Resend</a> or <a ng-click>Cancel</a> invitation )

					</div>
					<!-- END: Template for Invitation. -->

					<!-- BEGIN: Template for User. -->
					<div bn-repeat-switch-when="false" class="user">

						{{ person.name }} &mdash; {{ person.email }}

					</div>	
					<!-- END: Template for User. -->

				</li>
			</ul>

		</li>
		<!-- END: Outer NG-REPEAT. -->

	</ul>


	<!-- Load scripts. -->
	<script type="text/javascript" src="../../vendor/jquery/jquery-2.1.0.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs/angular-1.2.22.min.js"></script>
	<script type="text/javascript">

		// Create an application module for our demo.
		var app = angular.module( "Demo", [] );


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		// I control the root of the application.
		app.controller(
			"AppController",
			function( $scope, $timeout ) {

				// Create the first set of lists for the outer ng-repeat directive.
				$scope.invitationsA = [];
				$scope.usersA = [];

				// Build each set programmatically.
				for ( var i = 1 ; i <= 3 ; i++ ) {

					$scope.invitationsA.push({
						id: i,
						email: ( "ben+" + i + "@bennadel.com" )
					});

					$scope.usersA.push({
						id: i,
						name: ( "ben+" + i ),
						email: ( "ben+" + i + "@bennadel.com" )
					});

				}


				// Create the second set of lists for the outer ng-repeat directive.
				$scope.invitationsB = [];
				$scope.usersB = [];

				// Build each set programmatically.
				for ( var i = 4 ; i <= 6 ; i++ ) {

					$scope.invitationsB.push({
						id: i,
						email: ( "kim+" + i + "@bennadel.com" )
					});

					$scope.usersB.push({
						id: i,
						name: ( "kim+" + i ),
						email: ( "kim+" + i + "@bennadel.com" )
					});

				}


				// Create the outer collection of mixed-type lists.
				$scope.collections = [ 
					buildPeople( $scope.invitationsA, $scope.usersA ),
					buildPeople( $scope.invitationsB, $scope.usersB )
				];


				// I determine if the outer list is being shown. This is here to see 
				// if removing the list is able to properly deallocate the compiled
				// DOM node references.
				$scope.isShowingList = true;


				// ---
				// PUBLIC METHODS.
				// ---	


				// I toggle the visibility of the outer list.
				$scope.toggleList = function() {

					$scope.isShowingList = ! $scope.isShowingList;

				};


				// ---
				// PRIVATE METHODS.
				// ---	


				// I merge the given invitations and users collections into a single 
				// collection with unique ID (generated from the collection type and 
				// the ids of each item).
				function buildPeople( invitations, users ) {

					var people = sortPeople( invitations.concat( users ) );

					for ( var i = 0 ; i < people.length ; i++ ) {

						var person = people[ i ];

						// I determine if the given item is an invitation or a user.
						person.isInvitation = ! person.hasOwnProperty( "name" );

						// I build the unique ID for the item in the merged collection.
						person.uid = ( ( person.isInvitation ? "invitation-" : "user-" ) + person.id );

					}

					return( people );

				}
				

				// I sort the collection based on either name or email. Since I am 
				// sorting a mixed-collection, I am expecting not all elements to have 
				// a name; BUT, I am expecting all elements to have an email.
				function sortPeople( people ) {

					people.sort(
						function comparisonOperator( a, b ) {

							var nameA = ( a.name || a.email ).toLowerCase();
							var nameB = ( b.name || b.email ).toLowerCase();

							if ( nameA < nameB ) {

								return( -1 );

							} else if ( nameA > nameB ) {

								return( 1 );

							} else {

								return( 0 );

							}
							
						}
					);

					return( people );

				}

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		// I am a Switch/Case directive that is intended to work in conjunction with 
		// an ngRepat directive. I precompile the children tags with the attribute, 
		// "bn-repeat-switch-when (case/when) tags and then link them for each cloned
		// item in the ngRepeat rendering. Currently, this directive will clear out the
		// contents of the ngRepeat before rendering the appropriate "case" template.
		app.directive(
			"bnRepeatSwitch",
			function( $parse, $compile ) {

				// I provide a means to pass the switch expression and the switch cases
				// from this directive into the subsequent "linking" directive.
				function Controller() {

					// I hold the parsed expression that each ngRepeat clone will have 
					// to $watch() in order to figure out which template to render.
					this.expression = null;

					// I hold the linking functions for each "case" template.
					// --
					// NOTE: I am using .create(null) here in order to make sure that 
					// this object does NOT inherit keys from any other prototype. This 
					// allows us to check keys on this object without having to worry 
					// about inheritance. 
					this.cases = Object.create( null );

				}


				// I compile the ngRepeat element (before ngRepeat executes) in order to
				// pre-compile the rendering templates and prepare the linking functions.
				function compile( tElement, tAttributes ) {

					// Parse the expression that we want to watch/switch-on in each of 
					// the individual ngRepeat elements. By parsing it here, during the 
					// compilation phase, we save the overhead of having to parse it 
					// every time the ngRepeat elements is cloned and linked.
					var switchExpression = $parse( tAttributes.bnRepeatSwitch );

					// Find all the children elements that make up the "case" statements,
					// strip them out, and compile them. This way, we can simply clone 
					// and link them later on.
					// --
					// NOTE: Since we are manually querying the DOM for these elements, 
					// we have to make assumptions about the format of the target 
					// attribute. We don't get to rely on the normalization AngularJS 
					// usually gives us.
					var switchCases = {};

					// Find, compile, and remove case-templates.
					tElement
						.children( "[ bn-repeat-switch-when ]" )
						.remove()
						.each(
							function iterateOverCaseTemplates() {

								var node = angular.element( this );
								var caseValue = node.attr( "bn-repeat-switch-when" );
								var caseLinkFunction = $compile( node.removeAttr( "bn-repeat-switch-when" ) );

								switchCases[ caseValue ] = caseLinkFunction;

							}
						)
					;

					// Clear out any remaining content - the current state of this 
					// directive is not designed to use positional DOM insertion (the way
					// that ngSwitchWhen does).
					tElement.empty();

					// Since this directive is compiling and linking BEFORE the ngRepeat,
					// it means that it will only be linked once (for this ngRepeat). 
					// However, in order for this workflow to work, we need to have 
					// access to the linking phase of EACH ngRepeat item. As such, we 
					// have to inject another directive with a lower priority that will 
					// compile/link AFTER the ngRepeat directive.
					// --
					// NOTE: If this ngRepeat is contained INSIDE another directive that
					// does transclusion, then THIS directive may be linked more than 
					// once. But, it will only be linked once per sibling ngRepeat.
					tElement.attr( "bn-repeat-switch-on", "" );

					// Strip out the old attribute just to make the DOM a little smaller.
					// Now that we have compiled the expression, we no longer need access
					// to it on the DOM.
					tElement.removeAttr( tAttributes.$attr.bnRepeatSwitch );

					// Clean up references that we no longer need.
					tElement = null;
					tAttributes = null;

					
					// The primary purpose of this linking phase, for this directive, 
					// is to copy the switch expression and the case-link-functions into
					// the current Controller so that they can be made available to the
					// subsequent "On" directive linking phase.
					function link( $scope, element, attributes, controller ) {

						// Store the expressions. 
						controller.expression = switchExpression;
						controller.cases = switchCases;

						// Since our Controller is going to be passed-around, we should
						// probably tear it down in order to help prevent unexpected 
						// memory references from sticking around.
						$scope.$on(
							"$destroy",
							function handleDestroyEvent() {

								controller.expression = null;
								controller.cases = null;
								controller = null;

							}
						);

					}


					// Return the linking function (which will run before the ngRepeat
					// linking phase).
					return( link );

				}
				

				// Return the directive configuration. Note that this directive has to 
				// execute with priority 1,001 so that it is compiled BEFORE the ngRepeat
				// is compiled and linked (at 1,000). 
				return({
					compile: compile,
					controller: Controller,
					priority: 1001,
					required: "bnRepeatSwitch",
					restrict: "A"
				});

			}
		);


		// I am the sister directive for "bnRepeatSwitch". The bnRepeatSwitch directive 
		// compiles and links BEFORE the ngRepat directive. My job is to then compile 
		// and link AFTER the ngRepeat directive such that I am linked for each clone 
		// that the ngRepeat directives creates.
		app.directive(
			"bnRepeatSwitchOn",
			function() {

				// After each ngRepeat element is cloned, I set up the watcher to render
				// the appropriate template as the expression outcome changes.
				function link( $scope, element, attributes, switchController ) {

					// Start watching the precompiled expression.
					$scope.$watch(
						switchController.expression,
						function handleSwitchExpressionChange( newValue, oldValue ) {

							var linkFunction = switchController.cases[ newValue ];

							// If there was no matching case statement template, just 
							// clear out the content.
							if ( ! linkFunction ) {

								return( element.empty() );

							}

							// If the expression outcome is changing, clear out the 
							// content before rendering the new template.
							if ( newValue !== oldValue ) {

								element.empty();	

							}

							// Clone the case template and inject it into the DOM.
							linkFunction(
								$scope,
								function handleCaseTemplateCloneLinking( clone ) {

									element.append( clone );

								}
							);

						}
					);

				}


				// Return the directives configuration. Require the Controller for the 
				// "switch" directive so that we can access the Expression and Case 
				// templates that were generated during the compile phase.
				// --
				// NOTE: This directive has to execute with the priority 999 so that it
				// is linked AFTER the ngRepeat directive is linked (at 1,000). 
				return({
					link: link,
					priority: 999,
					require: "bnRepeatSwitch",
					restrict: "A"
				});
			}
		);

	</script>

</body>
</html>
